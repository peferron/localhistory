{"version":3,"sources":["/source/playbyplay.js","playbyplay.min.js"],"names":["global","factory","exports","module","define","amd","playbyplay","this","check","supportsLocalStorage","supportsJSON","supportsIsArray","supportsConsole","console","error","storage__save","run","runs","storage__load","length","sameRun","push","saveRuns","a","b","input","output","maxRuns","splice","runsStr","JSON","stringify","maxLength","trim","localStorage","runsKey","e","isQuotaError","Number","MAX_VALUE","code","name","safeParseJSON","Array","isArray","str","fallback","parse","index__save","setTimeout","storage","save","index__load","load","key","value","Math","random","window","Object","defineProperties","get","configurable","enumerable","maxBytes"],"mappings":"CAAC,SAAUA,EAAQC,GACI,gBAAZC,UAA0C,mBAAXC,QAAyBF,EAAQC,SACrD,kBAAXE,SAAyBA,OAAOC,IAAMD,QAAQ,WAAYH,GACjEA,EAASD,EAAOM,gBAClBC,KAAM,SAAUL,GAAW,YAsBzB,SAASM,KACL,MAAIC,IAAwBC,GAAgBC,GACjC,GAGPC,GACAC,QAAQC,MAAM,gDAGX,GAmCX,QAASC,GAAcC,GACnB,GAAMC,GAAOC,GACTD,GAAKE,QAAUC,EAAQJ,EAAKC,EAAKA,EAAKE,OAAS,MAInDF,EAAKI,KAAKL,GACVM,EAASL,IAGb,QAASG,GAAQG,EAAGC,GAChB,MAAOD,IAAKC,GAAKD,EAAEE,QAAUD,EAAEC,OAASF,EAAEG,SAAWF,EAAEE,OAG3D,QAASJ,GAASL,GAKd,IAJIA,EAAKE,OAASQ,GACdV,EAAKW,OAAO,EAAGX,EAAKE,OAASQ,KAGpB,CACT,GAAIE,GAAUC,KAAKC,UAAUd,EAE7B,IAAIY,EAAQV,OAASa,EAArB,CACI,GAAIf,EAAKE,OAAS,EAGd,WAFAN,SAAQC,MAAM,yCAAyCe,EAAQV,OAAM,MAAA,YACrDa,EAAS,eAI7BC,GAAKhB,OAIT,KAEI,YADAiB,aAAaC,GAAWN,GAE1B,MAAOO,GACL,GAAIC,EAAaD,GAAI,CACjB,GAAInB,EAAKE,OAAS,EAGd,WAFAN,SAAQC,MAAM,yCAAyCe,EAAQV,OAAM,+BAKzEN,SAAQC,MAAM,2FAEdmB,EAAKhB,EACL,UAIJ,WADAJ,SAAQC,MAAM,iDAAkDsB,KAM5E,QAASH,GAAKhB,GACVA,EAAKW,OAAOX,EAAKE,OAAS,EAAGmB,OAAOC,WAGxC,QAASF,GAAaD,GAClB,MAAOA,KAAiB,KAAXA,EAAEI,MAA0B,OAAXJ,EAAEI,MAA4B,+BAAXJ,EAAEK,MAKvD,QAASvB,KACL,GAAMW,GAAUK,aAAaC,EAC7B,KAAKN,EACD,QAGJ,IAAMZ,GAAOyB,EAAcb,EAC3B,OAAKc,OAAMC,QAAQ3B,GAIZA,KAGX,QAASyB,GAAcG,EAAKC,GACxB,IACI,MAAOhB,MAAKiB,MAAMF,GACpB,MAAOT,IAGT,MAAOU,GAGX,QAASE,GAAYhC,GACjB,MAAKR,KAIAQ,GAAQA,EAAIS,OAAUT,EAAIU,WAK/BuB,YAAW,WCSP,MDTaC,GAAQC,KAAKnC,IAAM,OAJhCH,SAAQC,MAAM,6DALlB,OAYJ,QAASsC,KACL,MAAK5C,KAIE0C,EAAQG,UA3KnB,GAAM5C,GAAuB,WACzB,GAAM6C,GAAM,0CACNC,EAAQC,KAAKC,SAAW,EAE9B,KAEI,GADAvB,aAAaoB,GAAOC,EAChBrB,aAAaoB,KAASC,EACtB,OAAO,EAEb,MAAOnB,GACL,OAAO,EAGX,OAAO,KAGL1B,EAAe,QAAUgD,SAAU,SAAW5B,OAAQ,aAAeA,MACrEnB,EAAkB,WAAagC,OAC/B/B,EAAkB,WAAa8C,SAAU,OAAS7C,UAAW,SAAWA,SAc1EqC,EAAOS,OAAAC,qBACHT,MCAAU,IDAK,WAAK,MAAO9C,ICGjB+C,cAAc,EACdC,YAAY,GDHZV,MCMAQ,IDNK,WAAK,MAAO3C,ICSjB4C,cAAc,EACdC,YAAY,KDQd5B,EAAU,uCAGV6B,EAAW,IAGXhC,EAAuB,EAAXgC,EAAe,GAE3BrC,EAAU,GAkHhBzB,GAAQiD,KAAOH,EACf9C,EAAQmD,KAAOD","file":"playbyplay.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    factory((global.playbyplay = {}))\n}(this, function (exports) { 'use strict';\n\n    const supportsLocalStorage = (() => {\n        const key = 'playbyplay_support_Vo8yTd6aLS$A8huo9$e7';\n        const value = Math.random() + '';\n\n        try {\n            localStorage[key] = value;\n            if (localStorage[key] !== value) {\n                return false;\n            }\n        } catch (e) {\n            return false;\n        }\n\n        return true;\n    })();\n\n    const supportsJSON = 'JSON' in window && 'parse' in JSON && 'stringify' in JSON;\n    const supportsIsArray = 'isArray' in Array;\n    const supportsConsole = 'console' in window && 'log' in console && 'error' in console;\n\n    function check() {\n        if (supportsLocalStorage && supportsJSON && supportsIsArray) {\n            return true;\n        }\n\n        if (supportsConsole) {\n            console.error('playbyplay is not supported in this browser');\n        }\n\n        return false;\n    }\n\n    var storage = {\n        get save () { return storage__save; },\n        get load () { return storage__load; }\n    };\n\n    // Optimization ideas if benchmarking reveals performance issues:\n    //\n    // - Do not parse the old runs. The string obtained from localStorage must look like this:\n    //       '[\"old_run\",\"old_run\",...]'\n    //   We could stringify the new run and insert it after the opening bracket:\n    //       '[\"new_run\",\"old_run\",\"old_run\",...]'\n    //   Bonus: when the quota is exceeded, we remove the second half of the array, which is more\n    //   performant than removing the first half.\n    //\n    // - Compression: https://github.com/pieroxy/lz-string\n    //   Could be especially good if the history contains many mostly-similar runs.\n    //\n    // - When trimming because of maxRuns, remove half of the array instead of typically just one run.\n    //   This way, future saves will not need to trim.\n\n    const runsKey = 'playbyplay_runs_A*O%y21#Q1WSh^f09YO!';\n\n    // Max history size in bytes.\n    const maxBytes = 50000;\n\n    // Max length of the stored string. Assumes 16 bits per character.\n    const maxLength = maxBytes * 8 / 16;\n\n    const maxRuns = 200;\n\n    // Save\n\n    function storage__save(run) {\n        const runs = storage__load();\n        if (runs.length && sameRun(run, runs[runs.length - 1])) {\n            return;\n        }\n\n        runs.push(run);\n        saveRuns(runs);\n    }\n\n    function sameRun(a, b) {\n        return a && b && a.input === b.input && a.output === b.output;\n    }\n\n    function saveRuns(runs) {\n        if (runs.length > maxRuns) {\n            runs.splice(0, runs.length - maxRuns);\n        }\n\n        while (true) { // eslint-disable-line no-constant-condition\n            let runsStr = JSON.stringify(runs);\n\n            if (runsStr.length > maxLength) {\n                if (runs.length < 2) {\n                    console.error(`playbyplay: cannot save run of length ${runsStr.length}, ` +\n                        `limit is ${maxLength} code units`);\n                    return;\n                }\n\n                trim(runs);\n                continue;\n            }\n\n            try {\n                localStorage[runsKey] = runsStr;\n                return;\n            } catch (e) {\n                if (isQuotaError(e)) {\n                    if (runs.length < 2) {\n                        console.error(`playbyplay: cannot save run of length ${runsStr.length}, ` +\n                            `exceeds localStorage quota`);\n                        return;\n                    }\n\n                    console.error('playbyplay: localStorage quota exceeded, discarding oldest ' +\n                        'half of history and retrying');\n                    trim(runs);\n                    continue;\n                }\n\n                console.error('playbyplay: could not save run to localStorage', e);\n                return;\n            }\n        }\n    }\n\n    function trim(runs) {\n        runs.splice(runs.length / 2, Number.MAX_VALUE);\n    }\n\n    function isQuotaError(e) {\n        return e && (e.code === 22 || e.code === 1014 && e.name === 'NS_ERROR_DOM_QUOTA_REACHED');\n    }\n\n    // Load\n\n    function storage__load() {\n        const runsStr = localStorage[runsKey];\n        if (!runsStr) {\n            return [];\n        }\n\n        const runs = safeParseJSON(runsStr);\n        if (!Array.isArray(runs)) {\n            return [];\n        }\n\n        return runs;\n    }\n\n    function safeParseJSON(str, fallback) {\n        try {\n            return JSON.parse(str);\n        } catch (e) { // eslint-disable-line no-empty\n        }\n\n        return fallback;\n    }\n\n    function index__save(run) {\n        if (!check()) {\n            return;\n        }\n\n        if (!run || !run.input || !run.output) {\n            console.error('playbyplay.save: input and output properties are required');\n            return;\n        }\n\n        setTimeout(() => storage.save(run), 0);\n    }\n\n    function index__load() {\n        if (!check()) {\n            return [];\n        }\n\n        return storage.load();\n    }\n\n    exports.save = index__save;\n    exports.load = index__load;\n\n}));\n",null],"sourceRoot":"/source/"}