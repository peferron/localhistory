{"version":3,"sources":["localhistory.js","localhistory.min.js"],"names":["global","factory","exports","module","define","amd","localhistory","this","throwIfUnsupported","support__supported","Error","consoleWarn","console","warn","apply","arguments","e","storage__append","key","entry","options","maxEntries","entries","undefined","storage__load","err","support","message","length","sameEntry","push","appendEntries","a","b","JSON","stringify","splice","entriesStr","entriesBytes","maxBytes","removeFirstHalf","localStorage","isQuotaError","arr","Math","ceil","code","name","parse","Array","isArray","storage__clear","removeItem","promisify","fn","callback","promise","Promise","resolve","reject","exec","result","index__append","cb","opts","fillAppendOptions","storage","append","isNaN","index__load","load","index__clear","clear","Object","defineProperties","supported","get","configurable","enumerable","supportsLocalStorage","value","random","success","index__supported"],"mappings":"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","file":"localhistory.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    factory((global.localhistory = {}))\n}(this, function (exports) {\n\n    var support = {\n        get supported () { return support__supported; },\n        get throwIfUnsupported () { return throwIfUnsupported; },\n        get promise () { return promise; },\n        get consoleWarn () { return consoleWarn; }\n    };\n\n    // Required features.\n\n    const supportsLocalStorage = (() => {\n        const key = 'localhistory_support_Vo8yTd6aLS$A8huo9$e7';\n        const value = Math.random() + '';\n\n        try {\n            localStorage[key] = value;\n            const success = localStorage[key] === value;\n            localStorage.removeItem(key);\n            return success;\n        } catch (e) {\n            return false;\n        }\n    })();\n\n    const support__supported = supportsLocalStorage && typeof JSON === 'object' && 'isArray' in Array;\n\n    function throwIfUnsupported() {\n        if (!support__supported) {\n            throw new Error('This browser does not support localhistory');\n        }\n    }\n\n    // Optional features.\n\n    const promise = typeof Promise === 'function';\n\n    function consoleWarn() {\n        try {\n            console.warn.apply(console, arguments); // eslint-disable-line no-console\n        } catch (e) { // eslint-disable-line no-empty\n        }\n    }\n\n    var storage = {\n        get append () { return storage__append; },\n        get load () { return storage__load; },\n        get clear () { return storage__clear; }\n    };\n\n    function storage__append(key, entry, options) {\n        if (options.maxEntries < 1) {\n            throw new Error(`Could not append entry, maxEntries is ${options.maxEntries}`);\n        }\n\n        let entries;\n        try {\n            entries = storage__load(key);\n        } catch (err) {\n            support.consoleWarn('localhistory: could not load previous entries, resetting history',\n                err.message);\n            entries = [];\n        }\n\n        if (entries.length && sameEntry(entry, entries[entries.length - 1])) {\n            return;\n        }\n\n        entries.push(entry);\n        appendEntries(key, entries, options);\n    }\n\n    function sameEntry(a, b) {\n        return JSON.stringify(a) === JSON.stringify(b);\n    }\n\n    function appendEntries(key, entries, options) {\n        if (entries.length > options.maxEntries) {\n            entries.splice(0, entries.length - options.maxEntries);\n        }\n\n        while (true) { // eslint-disable-line no-constant-condition\n            const entriesStr = JSON.stringify(entries);\n\n            const entriesBytes = entriesStr.length * 2; // Assumes 16 bits (2 bytes) per code point.\n            if (entriesBytes > options.maxBytes) {\n                if (entries.length < 2) {\n                    throw new Error(`Could not append entry of length ${entriesStr.length} ` +\n                        `(${entriesBytes} bytes), maxBytes is ${options.maxBytes}`);\n                }\n\n                removeFirstHalf(entries);\n                continue;\n            }\n\n            try {\n                localStorage[key] = entriesStr;\n                return;\n            } catch (err) {\n                if (isQuotaError(err)) {\n                    if (entries.length < 2) {\n                        throw new Error(`Could not append entry of length ${entriesStr.length}, ` +\n                            `exceeds localStorage quota`);\n                    }\n\n                    removeFirstHalf(entries);\n                    continue;\n                }\n\n                throw err;\n            }\n        }\n    }\n\n    function removeFirstHalf(arr) {\n        arr.splice(0, Math.ceil(arr.length / 2));\n    }\n\n    function isQuotaError(err) {\n        return err &&\n            (err.code === 22 ||\n             err.code === 1014 && err.name === 'NS_ERROR_DOM_QUOTA_REACHED');\n    }\n\n    function storage__load(key) {\n        const entriesStr = localStorage[key];\n        if (!entriesStr) {\n            return [];\n        }\n\n        const entries = JSON.parse(entriesStr);\n        if (!Array.isArray(entries)) {\n            throw new Error('Loaded entries are not an Array');\n        }\n\n        return entries;\n    }\n\n    function storage__clear(key) {\n        localStorage.removeItem(key);\n    }\n\n    function promisify(fn, callback) {\n        if (!support.promise) {\n            exec(fn, callback);\n            return;\n        }\n\n        return new Promise((resolve, reject) => { // eslint-disable-line consistent-return\n            exec(fn, (err, result) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(result);\n                }\n\n                if (callback) {\n                    callback(err, result);\n                }\n            });\n        });\n    }\n\n    function exec(fn, callback) {\n        let err = null;\n        let result;\n        try {\n            result = fn();\n        } catch (e) {\n            err = e;\n        }\n\n        if (callback) {\n            callback(err, result);\n        }\n    }\n\n    const index__supported = support.supported;\n\n    function index__append(key, entry, options, callback) {\n        const cb = typeof options === 'function' ? options : callback;\n        const opts = fillAppendOptions(typeof options === 'object' ? options : {});\n\n        return promisify(() => {\n            support.throwIfUnsupported();\n            storage.append(key, entry, opts);\n        }, cb);\n    }\n\n    function fillAppendOptions(options) {\n        if (isNaN(options.maxEntries)) {\n            options.maxEntries = 100;\n        }\n        if (isNaN(options.maxBytes)) {\n            options.maxBytes = 100000;\n        }\n        return options;\n    }\n\n    function index__load(key, callback) {\n        return promisify(() => {\n            support.throwIfUnsupported();\n            return storage.load(key);\n        }, callback);\n    }\n\n    function index__clear(key, callback) {\n        return promisify(() => {\n            support.throwIfUnsupported();\n            storage.clear(key);\n        }, callback);\n    }\n\n    exports.supported = index__supported;\n    exports.append = index__append;\n    exports.load = index__load;\n    exports.clear = index__clear;\n\n}));\n","!function(e,n){\"object\"==typeof exports&&\"undefined\"!=typeof module?n(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],n):n(e.localhistory={})}(this,function(e){function n(){if(!b)throw new Error(\"This browser does not support localhistory\")}function r(){try{console.warn.apply(console,arguments)}catch(e){}}function t(e,n,r){if(r.maxEntries<1)throw new Error(\"Could not append entry, maxEntries is \"+r.maxEntries);var t=void 0;try{t=c(e)}catch(a){y.consoleWarn(\"localhistory: could not load previous entries, resetting history\",a.message),t=[]}t.length&&o(n,t[t.length-1])||(t.push(n),i(e,t,r))}function o(e,n){return JSON.stringify(e)===JSON.stringify(n)}function i(e,n,r){for(n.length>r.maxEntries&&n.splice(0,n.length-r.maxEntries);;){var t=JSON.stringify(n),o=2*t.length;if(o>r.maxBytes){if(n.length<2)throw new Error(\"Could not append entry of length \"+t.length+\" \"+(\"(\"+o+\" bytes), maxBytes is \"+r.maxBytes));a(n)}else try{return void(localStorage[e]=t)}catch(i){if(u(i)){if(n.length<2)throw new Error(\"Could not append entry of length \"+t.length+\", exceeds localStorage quota\");a(n);continue}throw i}}}function a(e){e.splice(0,Math.ceil(e.length/2))}function u(e){return e&&(22===e.code||1014===e.code&&\"NS_ERROR_DOM_QUOTA_REACHED\"===e.name)}function c(e){var n=localStorage[e];if(!n)return[];var r=JSON.parse(n);if(!Array.isArray(r))throw new Error(\"Loaded entries are not an Array\");return r}function f(e){localStorage.removeItem(e)}function l(e,n){return y.promise?new Promise(function(r,t){s(e,function(e,o){e?t(e):r(o),n&&n(e,o)})}):void s(e,n)}function s(e,n){var r=null,t=void 0;try{t=e()}catch(o){r=o}n&&n(r,t)}function p(e,n,r,t){var o=\"function\"==typeof r?r:t,i=d(\"object\"==typeof r?r:{});return l(function(){y.throwIfUnsupported(),v.append(e,n,i)},o)}function d(e){return isNaN(e.maxEntries)&&(e.maxEntries=100),isNaN(e.maxBytes)&&(e.maxBytes=1e5),e}function g(e,n){return l(function(){return y.throwIfUnsupported(),v.load(e)},n)}function h(e,n){return l(function(){y.throwIfUnsupported(),v.clear(e)},n)}var y=Object.defineProperties({},{supported:{get:function(){return b},configurable:!0,enumerable:!0},throwIfUnsupported:{get:function(){return n},configurable:!0,enumerable:!0},promise:{get:function(){return w},configurable:!0,enumerable:!0},consoleWarn:{get:function(){return r},configurable:!0,enumerable:!0}}),m=function(){var e=\"localhistory_support_Vo8yTd6aLS$A8huo9$e7\",n=Math.random()+\"\";try{localStorage[e]=n;var r=localStorage[e]===n;return localStorage.removeItem(e),r}catch(t){return!1}}(),b=m&&\"object\"==typeof JSON&&\"isArray\"in Array,w=\"function\"==typeof Promise,v=Object.defineProperties({},{append:{get:function(){return t},configurable:!0,enumerable:!0},load:{get:function(){return c},configurable:!0,enumerable:!0},clear:{get:function(){return f},configurable:!0,enumerable:!0}}),x=y.supported;e.supported=x,e.append=p,e.load=g,e.clear=h});\n//# sourceMappingURL=localhistory.min.js.map"],"sourceRoot":"/source/"}