{"version":3,"sources":["localhistory.js","localhistory.min.js"],"names":["global","factory","exports","module","define","amd","localhistory","this","throwIfUnsupported","support__supported","Error","consoleWarn","console","warn","apply","arguments","e","storage__append","key","entry","options","maxEntries","entries","undefined","storage__load","err","support","message","appendIfEqualToLast","length","sameEntry","push","appendEntries","a","b","JSON","stringify","splice","entriesStr","entriesBytes","maxBytes","removeFirstHalf","localStorage","isQuotaError","arr","Math","ceil","code","name","parse","Array","isArray","storage__clear","removeItem","promisify","fn","callback","promise","Promise","resolve","reject","exec","result","index__append","cb","opts","fillAppendOptions","storage","append","isNaN","hasOwnProperty","index__load","load","index__clear","clear","Object","defineProperties","supported","get","configurable","enumerable","supportsLocalStorage","random","value","success","index__supported"],"mappings":"CAAC,SAAUA,EAAQC,GACI,gBAAZC,UAA0C,mBAAXC,QAAyBF,EAAQC,SACrD,kBAAXE,SAAyBA,OAAOC,IAAMD,QAAQ,WAAYH,GACjEA,EAASD,EAAOM,kBAClBC,KAAM,SAAUL,GAgCd,QAASM,KACL,IAAKC,EACD,KAAM,IAAIC,OAAM,8CAQxB,QAASC,KACL,IACIC,QAAQC,KAAKC,MAAMF,QAASG,WAC9B,MAAOC,KASb,QAASC,GAAgBC,EAAKC,EAAOC,GACjC,GAAIA,EAAQC,WAAa,EACrB,KAAM,IAAIX,OAAK,yCAA0CU,EAAQC,WAGrE,IAAIC,GAAOC,MACX,KACID,EAAUE,EAAcN,GAC1B,MAAOO,GACLC,EAAQf,YAAY,mEAChBc,EAAIE,SACRL,MAGCF,EAAQQ,qBAAuBN,EAAQO,QACxCC,EAAUX,EAAOG,EAAQA,EAAQO,OAAS,MAI9CP,EAAQS,KAAKZ,GACba,EAAcd,EAAKI,EAASF,IAGhC,QAASU,GAAUG,EAAGC,GAClB,MAAOC,MAAKC,UAAUH,KAAOE,KAAKC,UAAUF,GAGhD,QAASF,GAAcd,EAAKI,EAASF,GAKjC,IAJIE,EAAQO,OAAST,EAAQC,YACzBC,EAAQe,OAAO,EAAGf,EAAQO,OAAST,EAAQC,cAGlC,CACT,GAAMiB,GAAaH,KAAKC,UAAUd,GAE5BiB,EAAmC,EAApBD,EAAWT,MAChC,IAAIU,EAAenB,EAAQoB,SAA3B,CACI,GAAIlB,EAAQO,OAAS,EACjB,KAAM,IAAInB,OAAM,oCAAoC4B,EAAWT,OAAM,KAAA,IAC7DU,EAAY,wBAAwBnB,EAAQoB,UAGxDC,GAAgBnB,OAIpB,KAEI,YADAoB,aAAaxB,GAAOoB,GAEtB,MAAOb,GACL,GAAIkB,EAAalB,GAAM,CACnB,GAAIH,EAAQO,OAAS,EACjB,KAAM,IAAInB,OAAM,oCAAoC4B,EAAWT,OAAM,+BAIzEY,GAAgBnB,EAChB,UAGJ,KAAMG,KAKlB,QAASgB,GAAgBG,GACrBA,EAAIP,OAAO,EAAGQ,KAAKC,KAAKF,EAAIf,OAAS,IAGzC,QAASc,GAAalB,GAClB,MAAOA,KACW,KAAbA,EAAIsB,MACS,OAAbtB,EAAIsB,MAA8B,+BAAbtB,EAAIuB,MAGlC,QAASxB,GAAcN,GACnB,GAAMoB,GAAaI,aAAaxB,EAChC,KAAKoB,EACD,QAGJ,IAAMhB,GAAUa,KAAKc,MAAMX,EAC3B,KAAKY,MAAMC,QAAQ7B,GACf,KAAM,IAAIZ,OAAM,kCAGpB,OAAOY,GAGX,QAAS8B,GAAelC,GACpBwB,aAAaW,WAAWnC,GAG5B,QAASoC,GAAUC,EAAIC,GACnB,MAAK9B,GAAQ+B,QAKN,GAAIC,SAAQ,SAACC,EAASC,GACzBC,EAAKN,EAAI,SAAC9B,EAAKqC,GACPrC,EACAmC,EAAOnC,GAEPkC,EAAQG,GAGRN,GACAA,EAAS/B,EAAKqC,WAbtBD,GAAKN,EAAIC,GAmBjB,QAASK,GAAKN,EAAIC,GACd,GAAI/B,GAAM,KACNqC,EAAMvC,MACV,KACIuC,EAASP,IACX,MAAOvC,GACLS,EAAMT,EAGNwC,GACAA,EAAS/B,EAAKqC,GAOtB,QAASC,GAAc7C,EAAKC,EAAOC,EAASoC,GACxC,GAAMQ,GAAwB,kBAAZ5C,GAAyBA,EAAUoC,EAC/CS,EAAOC,EAAqC,gBAAZ9C,GAAuBA,KAE7D,OAAOkC,GAAU,WACb5B,EAAQlB,qBACR2D,EAAQC,OAAOlD,EAAKC,EAAO8C,IAC5BD,GAGP,QAASE,GAAkB9C,GAUvB,MATIiD,OAAMjD,EAAQC,cACdD,EAAQC,WAAa,KAErBgD,MAAMjD,EAAQoB,YACdpB,EAAQoB,SAAW,KAElBpB,EAAQkD,eAAe,yBACxBlD,EAAQQ,qBAAsB,GAE3BR,EAIX,QAASmD,GAAYrD,EAAKsC,GACtB,MAAOF,GAAU,WAEb,MADA5B,GAAQlB,qBACD2D,EAAQK,KAAKtD,IACrBsC,GAIP,QAASiB,GAAavD,EAAKsC,GACvB,MAAOF,GAAU,WACb5B,EAAQlB,qBACR2D,EAAQO,MAAMxD,IACfsC,GA3NP,GAAI9B,GAAOiD,OAAAC,qBACHC,WCDAC,IDCU,WAAK,MAAOrE,ICEtBsE,cAAc,EACdC,YAAY,GDFZxE,oBCKAsE,IDLmB,WAAK,MAAOtE,ICQ/BuE,cAAc,EACdC,YAAY,GDRZvB,SCWAqB,IDXQ,WAAK,MAAOrB,ICcpBsB,cAAc,EACdC,YAAY,GDdZrE,aCiBAmE,IDjBY,WAAK,MAAOnE,ICoBxBoE,cAAc,EACdC,YAAY,KDhBdC,EAAuB,WACzB,GAAM/D,GAAM,wBAA0B2B,KAAKqC,SACrCC,EAAQ,GAAKtC,KAAKqC,SACpBE,GAAU,CAEd,KACI1C,aAAaxB,GAAOiE,EACpBC,EAAU1C,aAAaxB,KAASiE,EAClC,MAAOnE,IAET,IACI0B,aAAaW,WAAWnC,GAC1B,MAAOF,GACLoE,GAAU,EAGd,MAAOA,MAGL3E,EAAqBwE,GAAwC,gBAAT9C,OAAqB,WAAae,OAUtFO,EAA6B,kBAAZC,SAQnBS,EAAOQ,OAAAC,qBACHR,QCuBAU,IDvBO,WAAK,MAAO7D,IC0BnB8D,cAAc,EACdC,YAAY,GD1BZR,MC6BAM,ID7BK,WAAK,MAAOtD,ICgCjBuD,cAAc,EACdC,YAAY,GDhCZN,OCmCAI,IDnCM,WAAK,MAAO1B,ICsClB2B,cAAc,EACdC,YAAY,KD4FdK,EAAmB3D,EAAQmD,SA0CjC3E,GAAQ2E,UAAYQ,EACpBnF,EAAQkE,OAASL,EACjB7D,EAAQsE,KAAOD,EACfrE,EAAQwE,MAAQD","file":"localhistory.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    factory((global.localhistory = {}))\n}(this, function (exports) {\n\n    var support = {\n        get supported () { return support__supported; },\n        get throwIfUnsupported () { return throwIfUnsupported; },\n        get promise () { return promise; },\n        get consoleWarn () { return consoleWarn; }\n    };\n\n    // Required features.\n\n    const supportsLocalStorage = (() => {\n        const key = 'localhistory_support_' + Math.random();\n        const value = '' + Math.random();\n        let success = false;\n\n        try {\n            localStorage[key] = value;\n            success = localStorage[key] === value;\n        } catch (e) {}\n\n        try {\n            localStorage.removeItem(key);\n        } catch (e) {\n            success = false;\n        }\n\n        return success;\n    })();\n\n    const support__supported = supportsLocalStorage && typeof JSON === 'object' && 'isArray' in Array;\n\n    function throwIfUnsupported() {\n        if (!support__supported) {\n            throw new Error('This browser does not support localhistory');\n        }\n    }\n\n    // Optional features.\n\n    const promise = typeof Promise === 'function';\n\n    function consoleWarn() {\n        try {\n            console.warn.apply(console, arguments); // eslint-disable-line no-console\n        } catch (e) {}\n    }\n\n    var storage = {\n        get append () { return storage__append; },\n        get load () { return storage__load; },\n        get clear () { return storage__clear; }\n    };\n\n    function storage__append(key, entry, options) {\n        if (options.maxEntries < 1) {\n            throw new Error(`Could not append entry, maxEntries is ${options.maxEntries}`);\n        }\n\n        let entries;\n        try {\n            entries = storage__load(key);\n        } catch (err) {\n            support.consoleWarn('localhistory: could not load previous entries, resetting history',\n                err.message);\n            entries = [];\n        }\n\n        if (!options.appendIfEqualToLast && entries.length &&\n            sameEntry(entry, entries[entries.length - 1])) {\n            return;\n        }\n\n        entries.push(entry);\n        appendEntries(key, entries, options);\n    }\n\n    function sameEntry(a, b) {\n        return JSON.stringify(a) === JSON.stringify(b);\n    }\n\n    function appendEntries(key, entries, options) {\n        if (entries.length > options.maxEntries) {\n            entries.splice(0, entries.length - options.maxEntries);\n        }\n\n        while (true) { // eslint-disable-line no-constant-condition\n            const entriesStr = JSON.stringify(entries);\n\n            const entriesBytes = entriesStr.length * 2; // Assumes 16 bits (2 bytes) per code point.\n            if (entriesBytes > options.maxBytes) {\n                if (entries.length < 2) {\n                    throw new Error(`Could not append entry of length ${entriesStr.length} ` +\n                        `(${entriesBytes} bytes), maxBytes is ${options.maxBytes}`);\n                }\n\n                removeFirstHalf(entries);\n                continue;\n            }\n\n            try {\n                localStorage[key] = entriesStr;\n                return;\n            } catch (err) {\n                if (isQuotaError(err)) {\n                    if (entries.length < 2) {\n                        throw new Error(`Could not append entry of length ${entriesStr.length}, ` +\n                            `exceeds localStorage quota`);\n                    }\n\n                    removeFirstHalf(entries);\n                    continue;\n                }\n\n                throw err;\n            }\n        }\n    }\n\n    function removeFirstHalf(arr) {\n        arr.splice(0, Math.ceil(arr.length / 2));\n    }\n\n    function isQuotaError(err) {\n        return err &&\n            (err.code === 22 ||\n             err.code === 1014 && err.name === 'NS_ERROR_DOM_QUOTA_REACHED');\n    }\n\n    function storage__load(key) {\n        const entriesStr = localStorage[key];\n        if (!entriesStr) {\n            return [];\n        }\n\n        const entries = JSON.parse(entriesStr);\n        if (!Array.isArray(entries)) {\n            throw new Error('Loaded entries are not an Array');\n        }\n\n        return entries;\n    }\n\n    function storage__clear(key) {\n        localStorage.removeItem(key);\n    }\n\n    function promisify(fn, callback) {\n        if (!support.promise) {\n            exec(fn, callback);\n            return;\n        }\n\n        return new Promise((resolve, reject) => { // eslint-disable-line consistent-return\n            exec(fn, (err, result) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(result);\n                }\n\n                if (callback) {\n                    callback(err, result);\n                }\n            });\n        });\n    }\n\n    function exec(fn, callback) {\n        let err = null;\n        let result;\n        try {\n            result = fn();\n        } catch (e) {\n            err = e;\n        }\n\n        if (callback) {\n            callback(err, result);\n        }\n    }\n\n    const index__supported = support.supported;\n\n    // key and entry are required, options and callback are optional.\n    function index__append(key, entry, options, callback) {\n        const cb = typeof options === 'function' ? options : callback;\n        const opts = fillAppendOptions(typeof options === 'object' ? options : {});\n\n        return promisify(() => {\n            support.throwIfUnsupported();\n            storage.append(key, entry, opts);\n        }, cb);\n    }\n\n    function fillAppendOptions(options) {\n        if (isNaN(options.maxEntries)) {\n            options.maxEntries = 100;\n        }\n        if (isNaN(options.maxBytes)) {\n            options.maxBytes = 100000;\n        }\n        if (!options.hasOwnProperty('appendIfEqualToLast')) {\n            options.appendIfEqualToLast = true;\n        }\n        return options;\n    }\n\n    // key is required, callback is optional.\n    function index__load(key, callback) {\n        return promisify(() => {\n            support.throwIfUnsupported();\n            return storage.load(key);\n        }, callback);\n    }\n\n    // key is required, callback is optional.\n    function index__clear(key, callback) {\n        return promisify(() => {\n            support.throwIfUnsupported();\n            storage.clear(key);\n        }, callback);\n    }\n\n    exports.supported = index__supported;\n    exports.append = index__append;\n    exports.load = index__load;\n    exports.clear = index__clear;\n\n}));\n","!function(e,n){\"object\"==typeof exports&&\"undefined\"!=typeof module?n(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],n):n(e.localhistory={})}(this,function(e){function n(){if(!b)throw new Error(\"This browser does not support localhistory\")}function t(){try{console.warn.apply(console,arguments)}catch(e){}}function r(e,n,t){if(t.maxEntries<1)throw new Error(\"Could not append entry, maxEntries is \"+t.maxEntries);var r=void 0;try{r=c(e)}catch(i){y.consoleWarn(\"localhistory: could not load previous entries, resetting history\",i.message),r=[]}!t.appendIfEqualToLast&&r.length&&o(n,r[r.length-1])||(r.push(n),a(e,r,t))}function o(e,n){return JSON.stringify(e)===JSON.stringify(n)}function a(e,n,t){for(n.length>t.maxEntries&&n.splice(0,n.length-t.maxEntries);;){var r=JSON.stringify(n),o=2*r.length;if(o>t.maxBytes){if(n.length<2)throw new Error(\"Could not append entry of length \"+r.length+\" \"+(\"(\"+o+\" bytes), maxBytes is \"+t.maxBytes));i(n)}else try{return void(localStorage[e]=r)}catch(a){if(u(a)){if(n.length<2)throw new Error(\"Could not append entry of length \"+r.length+\", exceeds localStorage quota\");i(n);continue}throw a}}}function i(e){e.splice(0,Math.ceil(e.length/2))}function u(e){return e&&(22===e.code||1014===e.code&&\"NS_ERROR_DOM_QUOTA_REACHED\"===e.name)}function c(e){var n=localStorage[e];if(!n)return[];var t=JSON.parse(n);if(!Array.isArray(t))throw new Error(\"Loaded entries are not an Array\");return t}function f(e){localStorage.removeItem(e)}function l(e,n){return y.promise?new Promise(function(t,r){s(e,function(e,o){e?r(e):t(o),n&&n(e,o)})}):void s(e,n)}function s(e,n){var t=null,r=void 0;try{r=e()}catch(o){t=o}n&&n(t,r)}function p(e,n,t,r){var o=\"function\"==typeof t?t:r,a=d(\"object\"==typeof t?t:{});return l(function(){y.throwIfUnsupported(),E.append(e,n,a)},o)}function d(e){return isNaN(e.maxEntries)&&(e.maxEntries=100),isNaN(e.maxBytes)&&(e.maxBytes=1e5),e.hasOwnProperty(\"appendIfEqualToLast\")||(e.appendIfEqualToLast=!0),e}function h(e,n){return l(function(){return y.throwIfUnsupported(),E.load(e)},n)}function g(e,n){return l(function(){y.throwIfUnsupported(),E.clear(e)},n)}var y=Object.defineProperties({},{supported:{get:function(){return b},configurable:!0,enumerable:!0},throwIfUnsupported:{get:function(){return n},configurable:!0,enumerable:!0},promise:{get:function(){return w},configurable:!0,enumerable:!0},consoleWarn:{get:function(){return t},configurable:!0,enumerable:!0}}),m=function(){var e=\"localhistory_support_\"+Math.random(),n=\"\"+Math.random(),t=!1;try{localStorage[e]=n,t=localStorage[e]===n}catch(r){}try{localStorage.removeItem(e)}catch(r){t=!1}return t}(),b=m&&\"object\"==typeof JSON&&\"isArray\"in Array,w=\"function\"==typeof Promise,E=Object.defineProperties({},{append:{get:function(){return r},configurable:!0,enumerable:!0},load:{get:function(){return c},configurable:!0,enumerable:!0},clear:{get:function(){return f},configurable:!0,enumerable:!0}}),x=y.supported;e.supported=x,e.append=p,e.load=h,e.clear=g});\n//# sourceMappingURL=localhistory.min.js.map"],"sourceRoot":"/source/"}